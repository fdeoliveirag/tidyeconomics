[
  {
    "path": "posts/2021-03-12-raca-clusters-de-renda-e-classificacao-de-bairros-no-r/",
    "title": "Raça, clusters de renda e classificação de bairros no R",
    "description": "Um algoritmo simples de machine learning sobre a relação entre raça e renda nas cidades brasileiras.",
    "author": [
      {
        "name": "Felipe O. Gonçalves",
        "url": {}
      }
    ],
    "date": "2021-03-12",
    "categories": [
      "Raça",
      "Renda",
      "Censo Demográfico"
    ],
    "contents": "\n\nbody{\n  font-size: 14pt;\n}\nh1, h2, h3 {\n  text-align: left;\n}\ntd{font-size: 16px;}\ncode.r{font-size: 14px;}\npre{font-size: 12px;}\nEsta postagem representa um esforço preliminar no sentido de testar a possibilidade de prever o nível de renda de um bairro brasileiro apenas com base em sua configuração racial.\nO caso analisado será a cidade de origem do autor: a antiga João Pessoa, que conta com 63 bairros registrados no IBGE até então. O algoritmo, todavia, é generalizável para qualquer cidade. Seu instrumental é dividido em duas partes:\nNa primeira (não supervisionada), uma clusterização k-means agrupa os bairros em três classes relativas de renda: alta, média e baixa;\nNa segunda (supervisionada), uma classificação logística não-binária prevê a qual cluster o bairro pertence dada sua proporção de indivíduos brancos.\nPacotes\n\n\nlibrary(geobr)      # mapa de bairros\nlibrary(janitor)    # limpeza de nomes\nlibrary(MASS)       # logit ordenado\n#\nlibrary(tidyverse)\n\n\n\n\nDados\nA matéria-prima da análise é a Tabela 3177 do Censo Demográfico 2010.\nApós sua importação, um trabalho razoável de limpeza — valores ausentes, concisão, renivelamento e reordenação de categorias — resulta num data frame que apresenta as diferentes combinações para os 63 bairros entre 5 grupos raciais e 8 grupos de renda. É possível baixá-lo neste repositório.\n\n\ndf_pop <- read_rds(\"censo_3177_pb.rds\")\n\n# ex. bairro mais populoso da cidade, população parda\nfilter(df_pop, bairro == \"Mangabeira\", racial == \"Parda\")\n\n\n# A tibble: 9 x 4\n  bairro     racial renda              valor\n  <chr>      <fct>  <fct>              <dbl>\n1 Mangabeira Parda  Até 1/2 SM          1656\n2 Mangabeira Parda  Mais de 1/2 a 1 SM  8345\n3 Mangabeira Parda  Mais de 1 a 2 SM    6439\n4 Mangabeira Parda  Mais de 2 a 3 SM    1738\n5 Mangabeira Parda  Mais de 3 a 5 SM    1195\n6 Mangabeira Parda  Mais de 5 a 10 SM    509\n7 Mangabeira Parda  Mais de 10 SM         68\n8 Mangabeira Parda  Sem rendimento     12430\n9 Mangabeira Parda  Total              32380\n\n\n\n\nE para garantir uma visualização espacial dos dados, os polígonos dos bairros podem ser importados através do excelente {geobr}:\n\n\nsf_bairros <- geobr::read_neighborhood(year = 2010) %>%\n  filter(code_muni == 2507507) %>%  # código de João Pessoa\n  select(name_neighborhood, geom)\n\n\n\n\nContexto\nUm panorama das combinações raça-renda para o agregado dos bairros é bastante elucidativo e, dado o escopo do blog, suficiente como justificativa:\n\n\ndf_pop %>%\n  # para cada combinação entre raça e estrato de renda...\n  group_by(racial, renda) %>%\n  # ...o agregado de todos os bairros; e para cada grupo racial...\n  summarize(valor = sum(valor), .groups = \"drop_last\") %>%\n  # ...a proporção de cada estrato;\n  mutate(valor = valor / last(valor)) %>%\n  # formato largo (estratos de renda em colunas)\n  pivot_wider(names_from = renda, values_from = valor)\n\n\n\nRendimento mensal por grupo racial em João Pessoa (2010)\n\n\n\n\n\nSalários Mínimos\n\n\n\nPopulação\n\n\n< 1/2\n\n\n1/2 a 1\n\n\n1 a 2\n\n\n2 a 3\n\n\n3 a 5\n\n\n5 a 10\n\n\n> 10\n\n\nNenhum\n\n\nBranca\n\n\n3.6%\n\n\n20.1%\n\n\n15.9%\n\n\n6.1%\n\n\n6.6%\n\n\n7.3%\n\n\n4.6%\n\n\n35.7%\n\n\nParda\n\n\n6.2%\n\n\n25.6%\n\n\n15.4%\n\n\n4.6%\n\n\n4.2%\n\n\n3.5%\n\n\n1.6%\n\n\n38.9%\n\n\nPreta\n\n\n7.2%\n\n\n29.7%\n\n\n16.5%\n\n\n4.7%\n\n\n3.7%\n\n\n2.4%\n\n\n0.9%\n\n\n34.9%\n\n\nIndígena\n\n\n7.9%\n\n\n25.9%\n\n\n17.3%\n\n\n6.1%\n\n\n4.9%\n\n\n4.1%\n\n\n1.7%\n\n\n32.1%\n\n\nAmarela\n\n\n6.3%\n\n\n23.1%\n\n\n17.0%\n\n\n5.4%\n\n\n4.4%\n\n\n3.8%\n\n\n1.6%\n\n\n38.3%\n\n\nTotal\n\n\n5.1%\n\n\n23.4%\n\n\n15.7%\n\n\n5.3%\n\n\n5.2%\n\n\n5.1%\n\n\n2.9%\n\n\n37.2%\n\n\n@fdeoliveirag\nAs frações da população branca ganhando de dois salários mínimos em diante são sempre — e gradativamente — maiores que as respectivas frações dos outros grupos raciais. Estas, por sua vez, somente decrescem na medida em que a renda aumenta. \nget_split()\nUma boa tática para lidar com as variáveis é cindir os dados para elas terem suas bases próprias, manipulá-las separadamente e depois reuni-las.\nEvitando repetição desnecessária, é possível construir com tidy evaluation uma função usando dplyr::enquo() para chamar as colunas dentro do pipe:\n\n\nget_split <- function(y, x) {\n  # variável\n  x <- enquo(x)\n  # data frame\n  y %>%\n    # indivíduos por bairro pertencendo a cada categoria da variável\n    group_by(bairro, !!x) %>%\n    summarize(valor = sum(valor), .groups = \"drop\") %>%\n    # categorias formando colunas\n    pivot_wider(names_from = !!x, values_from = valor) %>%\n    # limpando os nomes das colunas\n    janitor::clean_names()\n}\n\n\n\n\nProporção de brancos\nCom os dados raciais, precisa-se da medida quantitativa de branquitude dos bairros:\n\n\nbranq <- df_pop %>%\n  get_split(racial) %>%\n  summarize(\n    bairro,\n    prop_branq = branca / total\n  )\n\nglimpse(branq)\n\n\nRows: 63\nColumns: 2\n$ bairro     <chr> \"Aeroclube\", \"Água Fria\", \"Altiplano Cabo Branco\"…\n$ prop_branq <dbl> 0.6256013, 0.5011933, 0.5281250, 0.2883413, 0.339…\n\n\n\n# branquitude\nbranq %>%\n  ggplot(aes(x = prop_branq)) +\n  geom_histogram(aes(y = ..density..)) +\n  geom_density()\n\n\n\nDistribuição racial dos bairros de João Pessoa (2010)\n\n\n\n\nClusters de renda\nNo caso dos dados de renda, tem-se como medida a participação de cada estrato na população ocupada dos bairros:\n\n\nrendim <- df_pop %>%\n  get_split(renda) %>%\n  mutate(\n    across(where(is.numeric),\n           ~ .x / (total - sem_rendimento))\n  ) %>%\n  select(bairro, contains(\"_sm\"))\n\nglimpse(rendim)\n\n\nRows: 63\nColumns: 8\n$ bairro             <chr> \"Aeroclube\", \"Água Fria\", \"Altiplano Cabo…\n$ ate_1_2_sm         <dbl> 0.008200837, 0.011596548, 0.067423231, 0.…\n$ mais_de_1_2_a_1_sm <dbl> 0.1358996, 0.2014563, 0.2830441, 0.598030…\n$ mais_de_1_a_2_sm   <dbl> 0.2060251, 0.2758900, 0.1965955, 0.200843…\n$ mais_de_2_a_3_sm   <dbl> 0.12702929, 0.17637540, 0.09012016, 0.031…\n$ mais_de_3_a_5_sm   <dbl> 0.17456067, 0.18959008, 0.11014686, 0.019…\n$ mais_de_5_a_10_sm  <dbl> 0.213221757, 0.121089536, 0.143858478, 0.…\n$ mais_de_10_sm      <dbl> 0.1350627615, 0.0240021575, 0.1088117490,…\n\nSeja por silhueta ou cotovelo, o número ótimo de clusters varia entre dois e três. Para trabalhar com a ideia de classe média, optou-se pelo último:\n\n\nset.seed(321)  # ordem dos clusters preservada\n\nk_rendim <- rendim %>%\n  summarize(\n    bairro,\n    cluster = select(., -bairro) %>%\n      kmeans(centers = 3, nstart = 10,\n             algorithm = \"Hartigan-Wong\") %>%\n      pluck(\"cluster\") %>%\n      as_factor()\n  )\n\nglimpse(k_rendim)\n\n\nRows: 63\nColumns: 2\n$ bairro  <chr> \"Aeroclube\", \"Água Fria\", \"Altiplano Cabo Branco\", \"…\n$ cluster <fct> 3, 3, 3, 1, 1, 3, 3, 1, 3, 3, 3, 2, 2, 2, 1, 1, 2, 1…\n\n\n\n# geografia\nk_rendim %>%\n  mutate(bairro = str_to_title(bairro)) %>%\n  inner_join(sf_ibge, by = c(\"bairro\" = \"name_neighborhood\")) %>%\n  ggplot(aes(geometry = geom, fill = cluster)) +\n  geom_sf()\n\n\n\nClusters dos bairros de João Pessoa por renda (2010)\n\nNota: O “buraco” no meio do mapa, na verdade, são mais de 500 hectares remanescentes de Mata Atlântica natural, que abrigam o Jardim Botânico da cidade.\n\n\n\n\nClassificação\nEstimando por logit ordenado:\n\n\npred_logit <- k_rendim %>%\n  inner_join(branq, by = \"bairro\") %>%\n  mutate(\n    pred = (cluster ~ prop_branq) %>%\n      MASS::polr(method = \"logistic\") %>%\n      predict(),\n    acc = (cluster == pred)\n  )\n\nglimpse(pred_logit)\n\n\nRows: 63\nColumns: 5\n$ bairro     <chr> \"Aeroclube\", \"Água Fria\", \"Altiplano Cabo Branco\"…\n$ cluster    <fct> 3, 3, 3, 1, 1, 3, 3, 1, 3, 3, 3, 2, 2, 2, 1, 1, 2…\n$ prop_branq <dbl> 0.6256013, 0.5011933, 0.5281250, 0.2883413, 0.339…\n$ pred       <fct> 3, 2, 3, 1, 1, 3, 2, 2, 3, 3, 3, 2, 3, 1, 1, 1, 2…\n$ acc        <lgl> TRUE, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE…\n\nNa prática, o que acontece com esse modelo bivariado é simplesmente uma otimização da escolha de três intervalos de branquitude para o encaixe de cada cluster:\n\n\n# intervalos\npred_logit %>%\n  filter(acc == TRUE) %>%\n  group_by(cluster) %>%\n  summarize(\n    min_prop_branq = min(prop_branq),\n    max_prop_branq = max(prop_branq),\n    .groups = \"drop\"\n  )\n\n\n# A tibble: 3 x 3\n  cluster min_prop_branq max_prop_branq\n  <fct>            <dbl>          <dbl>\n1 1                0.284          0.377\n2 2                0.396          0.501\n3 3                0.517          0.699\n\nPorém, a dimensão racial da estrutura socioeconômica da cidade é tão forte que mesmo essa simplicidade é capaz de prever corretamente o nível de renda de 51 dos 63 bairros:\n\n\n# acurácia por grupos\npred_logit %>%\n  group_by(cluster) %>%\n  summarize(\n    true = sum(acc == TRUE),\n    false = n() - true,\n    performance = true / n(),\n    .groups = \"drop\"\n  )\n\n\n# A tibble: 3 x 4\n  cluster  true false performance\n  <fct>   <int> <int>       <dbl>\n1 1          21     3       0.875\n2 2          12     6       0.667\n3 3          18     3       0.857\n\n# acurácia total\nsummarize(pred_logit, performance = sum(acc == TRUE) / n())\n\n\n# A tibble: 1 x 1\n  performance\n        <dbl>\n1       0.810\n\nLogo, ao separar os bairros de João Pessoa em três faixas de branquitude: i) de 28 a 38%; ii) de 39 a 50% e; iii) de 51 a 70% de brancos, torna-se possível classificar corretamente mais de 4/5 deles entre baixa, média e alta renda.\n\n\n# visualização final\npred_logit %>%\n  ggplot(aes(x = prop_branq, y = cluster)) +\n  geom_boxplot(aes(fill = cluster)) +\n  geom_jitter(aes(color = acc))\n\n\n\nBairros de João Pessoa: Raça vs. Renda (2010)\n\n\n\n\n\n\n\n###\n\n\n\n",
    "preview": "posts/2021-03-12-raca-clusters-de-renda-e-classificacao-de-bairros-no-r/explorando-o-sidra-com-tidyverse-parte-ii_files/figure-html5/unnamed-chunk-19-1.png",
    "last_modified": "2021-03-12T20:37:06-03:00",
    "input_file": "explorando-o-sidra-com-tidyverse-parte-ii.utf8.md",
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2021-02-22-explorando-o-sidra-com-tidyverse-parte-i/",
    "title": "Explorando o SIDRA com tidyverse - Parte I",
    "description": "Usando a composição do IPCA para calcular e visualizar o padrão da inflação acumulada no Brasil em tempos de Covid.",
    "author": [
      {
        "name": "Felipe O. Gonçalves",
        "url": {}
      }
    ],
    "date": "2021-02-22",
    "categories": [
      "Inflação",
      "SIDRA"
    ],
    "contents": "\n\nbody{\n  font-size: 14pt;\n}\nh1, h2, h3 {\n  text-align: left;\n}\ntd{font-size: 16px;}\ncode.r{font-size: 14px;}\npre{font-size: 12px;}\nEste blog estreia com a primeira parte de uma sequência de postagens que procurará explorar as bases de dados do SIDRA através de uma abordagem avançada de workflow no R.\nNa postagem de hoje, calcula-se a variação mensal acumulada do IPCA desagregado em grupos para, em seguida, construir-se um gráfico sobre a inflação brasileira durante a pandemia – com atenção especial à inflação de alimentos. \nPacotes\n\n\nlibrary(sidrar)     # importação via API\nlibrary(ggthemes)   # estética do gráfico\n#\nlibrary(tidyverse)\n\n\n\n\nDados\nNão será preciso baixar nenhum arquivo. Seguindo os passos abaixo, encontra-se a expressão que permitirá levar os dados direto para o R:\nAcessar o portal do SIDRA\nIPCA > Relação de Tabelas > 7061\nDefinir opções:\nVariável: variação mensal (%)\nGeral, grupo, subgrupo, item e subitem: 9 componentes\nMês: mar/2020 a jan/2021\nUnidade Territorial: Brasil\n\nArrastar os blocos até ficarem dispostos assim:\n\nMenu Inferior Direito: Links de Compartilhar > Parâmetros para a API\n Feito. Cria-se então um objeto com a expressão (a partir de \"/t\"):\n\n\n\nt7061 <- \"/t/7061/n1/all/v/306/p/last%2011/c315/7170,7445,7486,7558,7625,7660,7712,7766,7786/d/v306%202\"\n\n\n\n\n E esse objeto é suficiente para importar os dados por meio do providencial {sidrar}:\n\n\ndf_ibge <- sidrar::get_sidra(api = t7061)\n\nnames(df_ibge)\n\n\n [1] \"Nível Territorial (Código)\"                     \n [2] \"Nível Territorial\"                              \n [3] \"Brasil (Código)\"                                \n [4] \"Brasil\"                                         \n [5] \"Variável (Código)\"                              \n [6] \"Variável\"                                       \n [7] \"Mês (Código)\"                                   \n [8] \"Mês\"                                            \n [9] \"Geral, grupo, subgrupo, item e subitem (Código)\"\n[10] \"Geral, grupo, subgrupo, item e subitem\"         \n[11] \"Unidade de Medida (Código)\"                     \n[12] \"Unidade de Medida\"                              \n[13] \"Valor\"                                          \n\n\nManipulação\nDas treze colunas, apenas três serão necessárias aqui:\n\n\nipca <- df_ibge %>%\n  as_tibble() %>%\n  select(\n    date = \"Mês\",\n    component = \"Geral, grupo, subgrupo, item e subitem\",\n    mth_inflation = \"Valor\"\n  )\n\nhead(ipca, 9)\n\n\n# A tibble: 9 x 3\n  date       component                   mth_inflation\n  <chr>      <chr>                               <dbl>\n1 abril 2020 1.Alimentação e bebidas              1.57\n2 abril 2020 2.Habitação                         -0.1 \n3 abril 2020 3.Artigos de residência             -1.37\n4 abril 2020 4.Vestuário                          0.1 \n5 abril 2020 5.Transportes                       -2.66\n6 abril 2020 6.Saúde e cuidados pessoais         -0.22\n7 abril 2020 7.Despesas pessoais                 -0.14\n8 abril 2020 8.Educação                           0   \n9 abril 2020 9.Comunicação                       -0.2 \n\nOs dados vêm num padrão “comprido” ao invés de “largo”: não há uma coluna para cada componente, e isso faz com que se tenha nove observações para cada mês. Diante da finalidade desta postagem, o ideal será mantê-los assim.\n O cálculo da inflação acumulada para \\(t \\in \\{1,\\ ..., 11\\}\\) meses de pandemia é recursivo (depende dos próprios valores defasados). De uma variação mensal inicial \\(\\pi_1^{ac} = \\pi_1\\), tem-se\n\\[\\pi_t^{ac} = (1\\ +\\ \\frac{\\pi_t}{100})\\ \\times\\ \\pi_{t-1}^{ac}\\ +\\ \\pi_t\\ \\]\npara \\(t\\neq1\\). Essa atribuição requer a função purrr::accumulate() para ser realizada dentro do flow — em parceria com dplyr::group_by() para ser aplicada a cada componente em separado:\n\n\nipca <- ipca %>%\n  group_by(component) %>%         # agrupamento\n  mutate(\n    # .y\n    accum_inflation = accumulate(\n      mth_inflation,              # .x\n      ~ (1 + .x / 100) * .y + .x  # atribuição recursiva de .y\n    )\n  )\n\n\n\n Conferindo o primeiro e mais relevante componente do período:\n\n\nhead(arrange(ipca, component), 11)\n\n\n# A tibble: 11 x 4\n# Groups:   component [1]\n   date           component              mth_inflation accum_inflation\n   <chr>          <chr>                          <dbl>           <dbl>\n 1 abril 2020     1.Alimentação e bebid…          1.57            1.57\n 2 maio 2020      1.Alimentação e bebid…          0.33            1.91\n 3 junho 2020     1.Alimentação e bebid…          0.64            2.56\n 4 julho 2020     1.Alimentação e bebid…          0.42            2.99\n 5 agosto 2020    1.Alimentação e bebid…          1.17            4.19\n 6 setembro 2020  1.Alimentação e bebid…          2.54            6.84\n 7 outubro 2020   1.Alimentação e bebid…          1.9             8.87\n 8 novembro 2020  1.Alimentação e bebid…          2.28           11.4 \n 9 dezembro 2020  1.Alimentação e bebid…          1.37           12.9 \n10 janeiro 2021   1.Alimentação e bebid…          0.68           13.6 \n11 fevereiro 2021 1.Alimentação e bebid…          0.4            14.1 \n\n Agora, chega-se ao valor acumulado no final do período para todos os componentes:\n\n\nipca <- ipca %>%\n  summarize(\n    accum_inflation = last(accum_inflation),  # jan/2021\n    .groups = \"drop\"                          # desagrupamento\n  )\n\n\n\n E eis a matéria-prima do gráfico:\n\n\narrange(ipca, desc(accum_inflation))\n\n\n# A tibble: 9 x 2\n  component                   accum_inflation\n  <chr>                                 <dbl>\n1 1.Alimentação e bebidas              14.1  \n2 3.Artigos de residência               8.95 \n3 5.Transportes                         4.61 \n4 2.Habitação                           4.26 \n5 9.Comunicação                         2.93 \n6 6.Saúde e cuidados pessoais           1.83 \n7 7.Despesas pessoais                   1.15 \n8 4.Vestuário                           0.194\n9 8.Educação                           -0.671\n\nNota: Ao olhar para a deflação dos serviços educacionais, deve-se ter em conta que fevereiro, um mês particularmente importante para o componente, é o único que não se faz presente nos dados. \nVisualização\nO primeiro passo para o sucesso do gráfico de barras será, seguindo o embalo da formatação, reordenar a sequência de componentes com forcats::fct_reorder() de acordo com o tamanho da inflação acumulada:\n\n\nipca <- ipca %>%\n  mutate(\n    component = component %>%\n      str_sub(3) %>%                              # retirada de numeração\n      recode(                                     # concisão\n        \"Alimentação e bebidas\" = \"Alimentação\",\n        \"Artigos de residência\" = \"Residência\",\n        \"Saúde e cuidados pessoais\" = \"Saúde\",\n        \"Despesas pessoais\" = \"Desp. Pessoais\"\n      ) %>%\n      fct_reorder(accum_inflation)                # critério de ordenação\n  )\n\n\n\n A carcaça do gráfico já pode ser criada:\n\n\nipca %>%\n  ggplot(aes(accum_inflation, component)) +\n  geom_col()\n\n\n\n\nPorém ela é pouco apelativa (apesar de ter seu charme). O segundo passo será desfrutar das possibilidades de montagem em cima dessa carcaça — por exemplo, a função ggplot2::geom_label(). Esmiuçá-las exigiria uma postagem à parte.\nPor último, escolhe-se tema e paleta de cores a gosto. Como a inspiração para esta postagem veio justamente de matérias jornalísticas sobre a trajetória recente da inflação de alimentos, foi escolhido um padrão do Wall Street Journal encontrado no {ggthemes}:\n\n\n\nUm senhor ganho de apelo estético.\nNa segunda parte da sequência, será possível trabalhar com planilhas mais complexas do SIDRA. \n###\n\n\n\n",
    "preview": "posts/2021-02-22-explorando-o-sidra-com-tidyverse-parte-i/desmistificando-o-sidra-parte-i_files/figure-html5/unnamed-chunk-12-1.png",
    "last_modified": "2021-03-12T20:12:21-03:00",
    "input_file": "desmistificando-o-sidra-parte-i.utf8.md",
    "preview_width": 1248,
    "preview_height": 768
  }
]
